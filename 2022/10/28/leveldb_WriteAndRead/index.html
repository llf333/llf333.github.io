<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"llf333.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="leveldb源码阅读----读写流程">
<meta property="og:url" content="http://llf333.github.io/2022/10/28/leveldb_WriteAndRead/index.html">
<meta property="og:site_name" content="llf333">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://llf333.github.io/2022/10/28/leveldb_WriteAndRead/version.png">
<meta property="article:published_time" content="2022-10-28T13:22:36.000Z">
<meta property="article:modified_time" content="2022-10-28T13:27:34.839Z">
<meta property="article:author" content="llf333">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://llf333.github.io/2022/10/28/leveldb_WriteAndRead/version.png">

<link rel="canonical" href="http://llf333.github.io/2022/10/28/leveldb_WriteAndRead/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>leveldb源码阅读----读写流程 | llf333</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">llf333</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://llf333.github.io/2022/10/28/leveldb_WriteAndRead/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/llf.jpg">
      <meta itemprop="name" content="llf333">
      <meta itemprop="description" content="Every man is the master of his own fortune.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="llf333">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leveldb源码阅读----读写流程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-28 21:22:36 / Modified: 21:27:34" itemprop="dateCreated datePublished" datetime="2022-10-28T21:22:36+08:00">2022-10-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Database/" itemprop="url" rel="index"><span itemprop="name">Database</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<span id="more"></span>

<h1 id="leveldb源码阅读—-读写流程"><a href="#leveldb源码阅读—-读写流程" class="headerlink" title="leveldb源码阅读—-读写流程"></a>leveldb源码阅读—-读写流程</h1><p>在我看完几个组件的数据结构，感觉对leveldb的脉络把握的还不是很清楚，因此现在阅读源码的方式直接瞄向了用户接口，然后不断扩展，因此这篇博客是想要从leveldb暴露出最基本的读写接口出发，以此为脉络，介绍leveldb数据库的读写过程，并介绍一些相关的组件。</p>
<hr>
<h2 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h2><p>leveldb中有一个db.h，里面包含一个抽象类，提供作为数据库所需要的具体接口。而leveldb的具体实现则写在db_impl.h中，db_impl类继承于抽象基类db。</p>
<p>对于一个键对存储系统，所提供的写操作只有两类，一类是Put，一类是Delete。在LSM结构中，两个函数接口的实现基本一样，这主要因为LSM结构采用的是仅追加的方式进行写操作，因此对于Delete操作只需要通过Put一个“tombstone”的键对来完成，使用一个“tombstone”来对所有的旧版本进行覆盖。所以，leveldb中的Put和Delete中调用的是同一个函数——Write，只是构建的WriteBatch不同。下面则主要围绕WriteBatch和Write函数进行说明。</p>
<hr>
<h3 id="WriteBatch"><a href="#WriteBatch" class="headerlink" title="WriteBatch"></a>WriteBatch</h3><p>首先谈谈WtriteBatch类，我觉得<code>WriteBatch</code>这个设计的思路特别好。我对WtriteBatch的理解是，<strong>它是一个写请求的数据的封装，允许多个Write请求的数据放到一个WriteBatch中</strong>，每个写请求的信息全部存储在<code>std::string rep_</code>中。</p>
<p><code>rep_</code>的结构如下：</p>
<ul>
<li>squence：首先用八个字节（fixed64位）存当前写请求的版本号。</li>
<li>count：然后用四个字节（fixed32位）存当前写请求的kv数目。</li>
<li>data：然后跟的就是kv数据，kv数据分为两种，两种数据的长度不一样。<ul>
<li>kTypeValue：表示插入数据，具体数据是：一个字节表示类型 + 变长的key + 变长的value</li>
<li>kTypeDeletion：表示删除数据，具体数据是：一个字节表示类型 + 变长的key</li>
</ul>
</li>
</ul>
<p>为什么这样设计好？因为在并发写的过程中，<strong>写的时候需要加锁，每次加锁后如果只写一个kv，那么写的效率会大大地被频繁的加锁解锁所限制</strong>，所以为了提高并发度，每次加锁后的写，尽量多写一些，所以通过将多个写请求封装到同一个WriteBatch中，一次性写入MemTable中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LEVELDB_EXPORT</span> WriteBatch &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WriteBatch</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Intentionally copyable.</span></span><br><span class="line">    <span class="built_in">WriteBatch</span>(<span class="type">const</span> WriteBatch&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    WriteBatch&amp; <span class="keyword">operator</span>=(<span class="type">const</span> WriteBatch&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">WriteBatch</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">ApproximateSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> WriteBatch&amp; source)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Status <span class="title">Iterate</span><span class="params">(Handler* handler)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WriteBatchInternal</span>; <span class="comment">//包含了内部接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// WriteBatch::rep_ :=</span></span><br><span class="line">    <span class="comment">//    sequence: fixed64</span></span><br><span class="line">    <span class="comment">//    count: fixed32</span></span><br><span class="line">    <span class="comment">//    data: record[count]</span></span><br><span class="line">    <span class="comment">// record :=</span></span><br><span class="line">    <span class="comment">//    kTypeValue + varstring + varstring         |</span></span><br><span class="line">    <span class="comment">//    kTypeDeletion + varstring</span></span><br><span class="line">    <span class="comment">// varstring :=</span></span><br><span class="line">    <span class="comment">//    len: varint32</span></span><br><span class="line">    <span class="comment">//    data: uint8[len]</span></span><br><span class="line">    std::string rep_;  <span class="comment">// See comment in write_batch.cc for the format of rep_</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><p>Writer是一个写请求，在获得请求队列的锁之后，加到请求队列末尾，然后等待。等待至自己被完成，或者自己到达了队头。</p>
<p>如果自己被完成，则返回完成结果，如果自己在队头并还未开始执行写，则开始写。</p>
<p>怎么写呢？</p>
<p>先执行<code>MakeRoomForWrite</code>，顾明思议，就是保证memtable中有足够空间用来写，这个过程可能会有immutable memtable的落盘，后台的compaction等。</p>
<p>然后执行<code>BuildBatchGroup</code>，该函数所作的是从当前的请求开始，向后遍历请求，将他们包装到同一个WriteBatch中，在包装时，如果遇到sync需要特判，包装的写请求也有做大小限制。</p>
<p>然后写入log，如果sync为true，则立即刷盘。</p>
<p>然后写入MemTable中。</p>
<p>最后把写入的请求从请求队列弹出，并唤醒相关线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>&#123;</span><br><span class="line">  <span class="function">Writer <span class="title">w</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  w.batch = updates;</span><br><span class="line">  w.sync = options.sync;</span><br><span class="line">  w.done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  writers_.<span class="built_in">push_back</span>(&amp;w);</span><br><span class="line">  <span class="comment">// 如果在队头了就开始执行</span></span><br><span class="line">  <span class="keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.<span class="built_in">front</span>()) &#123;</span><br><span class="line">    w.cv.<span class="built_in">Wait</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不是特判，是当前w在别的writebatch整合里面已经被写了</span></span><br><span class="line">  <span class="keyword">if</span> (w.done) &#123;</span><br><span class="line">    <span class="keyword">return</span> w.status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// May temporarily unlock and wait.</span></span><br><span class="line">  <span class="comment">// 整个过程会导致数据库内部的一系列变化，例如：immutable memtable的落盘，后台的compaction等等。最后的结果是active的memtable中应当有足够的位置来容纳接下来的batch write。</span></span><br><span class="line">  Status status = <span class="built_in">MakeRoomForWrite</span>(updates == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">uint64_t</span> last_sequence = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">  Writer* last_writer = &amp;w;</span><br><span class="line">  <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; updates != <span class="literal">nullptr</span>) &#123;  <span class="comment">// nullptr batch is for compactions</span></span><br><span class="line">    <span class="comment">// 这个函数的目的主要是对队列后的一些请求作整合，有做大小限制，并对sync的请求有单独处理。</span></span><br><span class="line">    WriteBatch* write_batch = <span class="built_in">BuildBatchGroup</span>(&amp;last_writer); <span class="comment">// last_writer会变</span></span><br><span class="line">    WriteBatchInternal::<span class="built_in">SetSequence</span>(write_batch, last_sequence + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 一个writebatch里可能有多个record</span></span><br><span class="line">    last_sequence += WriteBatchInternal::<span class="built_in">Count</span>(write_batch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add to log and apply to memtable.  We can release the lock</span></span><br><span class="line">    <span class="comment">// during this phase since &amp;w is currently responsible for logging</span></span><br><span class="line">    <span class="comment">// and protects against concurrent loggers and concurrent writes</span></span><br><span class="line">    <span class="comment">// into mem_.</span></span><br><span class="line">    &#123;</span><br><span class="line">      mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">      <span class="comment">// 写入log</span></span><br><span class="line">      status = log_-&gt;<span class="built_in">AddRecord</span>(WriteBatchInternal::<span class="built_in">Contents</span>(write_batch));</span><br><span class="line">      <span class="type">bool</span> sync_error = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; options.sync) &#123;</span><br><span class="line">        <span class="comment">// 立即把log刷盘</span></span><br><span class="line">        status = logfile_-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          sync_error = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 写入memtable</span></span><br><span class="line">      <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        status = WriteBatchInternal::<span class="built_in">InsertInto</span>(write_batch, mem_);</span><br><span class="line">      &#125;</span><br><span class="line">      mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (sync_error) &#123;</span><br><span class="line">        <span class="comment">// The state of the log file is indeterminate: the log record we</span></span><br><span class="line">        <span class="comment">// just added may or may not show up when the DB is re-opened.</span></span><br><span class="line">        <span class="comment">// So we force the DB into a mode where all future writes fail.</span></span><br><span class="line">        <span class="built_in">RecordBackgroundError</span>(status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (write_batch == tmp_batch_) tmp_batch_-&gt;<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">    versions_-&gt;<span class="built_in">SetLastSequence</span>(last_sequence);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Writer* ready = writers_.<span class="built_in">front</span>();</span><br><span class="line">    writers_.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">if</span> (ready != &amp;w) &#123;</span><br><span class="line">      ready-&gt;status = status;</span><br><span class="line">      ready-&gt;done = <span class="literal">true</span>;</span><br><span class="line">      ready-&gt;cv.<span class="built_in">Signal</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ready == last_writer) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Notify new head of write queue</span></span><br><span class="line">  <span class="keyword">if</span> (!writers_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    writers_.<span class="built_in">front</span>()-&gt;cv.<span class="built_in">Signal</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h2><h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p>leveldb的读就只有一个Get函数。逻辑很简单，大体就是<strong>先读MemTable，读不到就再读Immutable，再读不到就读SSTable</strong>。读MemTable就是在<strong>Skiplist</strong>里面查询，这里就不赘述了，Immutable类似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::Get</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options, <span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                   std::string* value)</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line">  <span class="keyword">if</span> (options.snapshot != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    snapshot =</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;<span class="built_in">sequence_number</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    snapshot = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemTable* mem = mem_;</span><br><span class="line">  MemTable* imm = imm_;</span><br><span class="line">  Version* current = versions_-&gt;<span class="built_in">current</span>();</span><br><span class="line">  <span class="comment">// 引用计数</span></span><br><span class="line">  mem-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">  current-&gt;<span class="built_in">Ref</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> have_stat_update = <span class="literal">false</span>;</span><br><span class="line">  Version::GetStats stats;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">    <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123;  <span class="comment">// 读memtable</span></span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">nullptr</span> &amp;&amp; imm-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123; <span class="comment">//读immutable</span></span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = current-&gt;<span class="built_in">Get</span>(options, lkey, value, &amp;stats); <span class="comment">// 读sstable</span></span><br><span class="line">      have_stat_update = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;<span class="built_in">UpdateStats</span>(stats)) &#123;</span><br><span class="line">    <span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  mem-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  current-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读SSTable时，调用了一个叫做<code>current</code>的变量，current的类型是<code>Version</code>，在DBImpl中有一个变量叫做<code>versions_</code>，其类型是<code>VersionSet</code>，<code>VersionSet</code>就是一个双向循环链表，维护了多个<code>Version</code>，每个<code>Version</code>维护一个DB的版本，如下图，leveldb允许旧版本的存在和访问，<code>current</code>便取自于此，代表最新版本。<strong>利用current即可对所有的SSTable进行查找</strong>。</p>
<img src="/2022/10/28/leveldb_WriteAndRead/version.png">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Version</span>&#123;</span><br><span class="line">    ···</span><br><span class="line">  VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line">  Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line">  Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line">  <span class="type">int</span> refs_;          <span class="comment">// Number of live refs to this version</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// List of files per level</span></span><br><span class="line">  std::vector&lt;FileMetaData*&gt; files_[config::kNumLevels];<span class="comment">// 二维数组，所有level文件的元数据</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">  FileMetaData* file_to_compact_; <span class="comment">// 当文件查找到一定次数时，就需要执行合并操作</span></span><br><span class="line">  <span class="type">int</span> file_to_compact_level_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line">  <span class="comment">// Score &lt; 1 means compaction is not strictly needed.  These fields</span></span><br><span class="line">  <span class="comment">// are initialized by Finalize().</span></span><br><span class="line">  <span class="type">double</span> compaction_score_; <span class="comment">// 当score&gt;=1时，也需要进行合并 </span></span><br><span class="line">  <span class="type">int</span> compaction_level_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FileMetaData</span> &#123;</span><br><span class="line">  <span class="built_in">FileMetaData</span>() : <span class="built_in">refs</span>(<span class="number">0</span>), <span class="built_in">allowed_seeks</span>(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), <span class="built_in">file_size</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> refs;</span><br><span class="line">  <span class="type">int</span> allowed_seeks;     <span class="comment">// 允许最大的查找次数 --!! SSTable为什么查找一定次数后要compaction。</span></span><br><span class="line">  <span class="type">uint64_t</span> number;       <span class="comment">// 文件编号</span></span><br><span class="line">  <span class="type">uint64_t</span> file_size;    </span><br><span class="line">  InternalKey smallest;  <span class="comment">// 最大值和最小值提高查找效率</span></span><br><span class="line">  InternalKey largest;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从Version的Get函数，可以看到查找操作主要用了两个函数，如下。<strong>Get中的Match函数，作用是打开相应的SSTable，加载到缓冲中，然后进行查找，有了level和f中的number便可以唯一确定一个SSTable；ForEachOverlapping函数则对查找逻辑进行说明</strong>。文件查找SSTable的大体逻辑，就是先从level0里面找，由于level0里面的文件可能有重复键值，因此需要对每个文件做出判断，由于内部维护了元数据（最大key和最小key），我们可以对每个SSTable做出提前筛选，空间换时间，提高了查找效率。如果level0找不到，再依次向下面的level中寻找，这次由于文件之间没有重复键值，所以每个level只用查找一个文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Version::Get</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options, <span class="type">const</span> LookupKey&amp; k,</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::string* value, GetStats* stats)</span> </span>&#123;</span><br><span class="line">  stats-&gt;seek_file = <span class="literal">nullptr</span>;</span><br><span class="line">  stats-&gt;seek_file_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主要是对查询状态的封装，包括查找结果，上一个level是多少，option，key等</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">State</span>&#123;</span><br><span class="line">      ···</span><br><span class="line">      <span class="comment">// arg变量本质上是State类型，为什么要写成void*？</span></span><br><span class="line">      <span class="comment">// 因为State结构体是在该函数内声明的，在ForEachOverlapping里想用这个结构就不能用，所以用void*类型来表示。</span></span><br><span class="line">      <span class="comment">// 该函数的功能就是打开相应的SSTable，加载到缓冲中，然后进行查找。有了level和f中的number便可以唯一确定一个SSTable文件</span></span><br><span class="line">      <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Match</span><span class="params">(<span class="type">void</span>* arg, <span class="type">int</span> level, FileMetaData* f)</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  State state;</span><br><span class="line">  state.found = <span class="literal">false</span>;</span><br><span class="line">  state.stats = stats;</span><br><span class="line">  state.last_file_read = <span class="literal">nullptr</span>;</span><br><span class="line">  state.last_file_read_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  state.options = &amp;options;</span><br><span class="line">  state.ikey = k.<span class="built_in">internal_key</span>();</span><br><span class="line">  state.vset = vset_;</span><br><span class="line"></span><br><span class="line">  state.saver.state = kNotFound;</span><br><span class="line">  state.saver.ucmp = vset_-&gt;icmp_.<span class="built_in">user_comparator</span>();</span><br><span class="line">  state.saver.user_key = k.<span class="built_in">user_key</span>();</span><br><span class="line">  state.saver.value = value;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ForEachOverlapping</span>(state.saver.user_key, state.ikey, &amp;state, &amp;State::Match);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state.found ? state.s : Status::<span class="built_in">NotFound</span>(<span class="built_in">Slice</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Version::ForEachOverlapping</span><span class="params">(Slice user_key, Slice internal_key, <span class="type">void</span>* arg,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">bool</span> (*func)(<span class="type">void</span>*, <span class="type">int</span>, FileMetaData*))</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> Comparator* ucmp = vset_-&gt;icmp_.<span class="built_in">user_comparator</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search level-0 in order from newest to oldest.</span></span><br><span class="line">  <span class="comment">// 因为第0层可能有重复元素，所以需要对每个文件做出判断。</span></span><br><span class="line">  std::vector&lt;FileMetaData*&gt; tmp;</span><br><span class="line">  tmp.<span class="built_in">reserve</span>(files_[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    FileMetaData* f = files_[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">if</span> (ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;smallest.<span class="built_in">user_key</span>()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">        ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;largest.<span class="built_in">user_key</span>()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      tmp.<span class="built_in">push_back</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tmp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), NewestFirst);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="comment">// 调用Match函数</span></span><br><span class="line">      <span class="keyword">if</span> (!(*func)(arg, <span class="number">0</span>, tmp[i])) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search other levels.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">1</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="type">size_t</span> num_files = files_[level].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binary search to find earliest index whose largest key &gt;= internal_key.</span></span><br><span class="line">    <span class="comment">// 对其他level只用找一个可能的文件，这里的FindFile内部使用的是二分查找，找到相关文件</span></span><br><span class="line">    <span class="type">uint32_t</span> index = <span class="built_in">FindFile</span>(vset_-&gt;icmp_, files_[level], internal_key);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; num_files) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][index];</span><br><span class="line">      <span class="keyword">if</span> (ucmp-&gt;<span class="built_in">Compare</span>(user_key, f-&gt;smallest.<span class="built_in">user_key</span>()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// All of &quot;f&quot; is past any data for user_key</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(*func)(arg, level, f)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>llf333
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://llf333.github.io/2022/10/28/leveldb_WriteAndRead/" title="leveldb源码阅读----读写流程">http://llf333.github.io/2022/10/28/leveldb_WriteAndRead/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally. Please give credit to the original author when you use it elsewhere.
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/26/leveldb_Basic-Tools/" rel="prev" title="leveldb基本组件源码阅读">
      <i class="fa fa-chevron-left"></i> leveldb基本组件源码阅读
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/31/leveldb_3Tables/" rel="next" title="leveldb源码阅读----读SSTable">
      leveldb源码阅读----读SSTable <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>


  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E2%80%94-%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">leveldb源码阅读—-读写流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">写流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WriteBatch"><span class="nav-number">1.1.1.</span> <span class="nav-text">WriteBatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Write"><span class="nav-number">1.1.2.</span> <span class="nav-text">Write</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">读流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Get"><span class="nav-number">1.2.1.</span> <span class="nav-text">Get</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="llf333"
      src="/images/llf.jpg">
  <p class="site-author-name" itemprop="name">llf333</p>
  <div class="site-description" itemprop="description">Every man is the master of his own fortune.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/llf333" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;llf333" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa-light fa-watermelon-slice"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">llf333</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
