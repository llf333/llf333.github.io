<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="针对《Effective C++》各个条款的核心要点。">
<meta property="og:type" content="article">
<meta property="og:title" content="二刷Effective C++">
<meta property="og:url" content="http://example.com/2022/08/20/%E4%BA%8C%E5%88%B7Effective-C++/index.html">
<meta property="og:site_name" content="llf333">
<meta property="og:description" content="针对《Effective C++》各个条款的核心要点。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-08-20T12:56:44.759Z">
<meta property="article:modified_time" content="2022-08-21T07:27:40.015Z">
<meta property="article:author" content="llf333">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/08/20/%E4%BA%8C%E5%88%B7Effective-C++/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>二刷Effective C++ | llf333</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">llf333</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/20/%E4%BA%8C%E5%88%B7Effective-C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/llf.jpg">
      <meta itemprop="name" content="llf333">
      <meta itemprop="description" content="Every man is the master of his own fortune.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="llf333">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          二刷Effective C++
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-20 20:56:44" itemprop="dateCreated datePublished" datetime="2022-08-20T20:56:44+08:00">2022-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-21 15:27:40" itemprop="dateModified" datetime="2022-08-21T15:27:40+08:00">2022-08-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>针对《Effective C++》各个条款的核心要点。</p>
<span id="more"></span>





<p>注：部分笔记记录于<em><strong>侯捷C++视频.md</strong></em> 中</p>
<hr>
<h2 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h2><h3 id="1、-多用explicit"><a href="#1、-多用explicit" class="headerlink" title="1、 多用explicit"></a>1、 多用explicit</h3><p>可避免编译器执行非预期的类型转换。</p>
<h3 id="2、A-a-x3D-b；"><a href="#2、A-a-x3D-b；" class="headerlink" title="2、A a&#x3D;b；"></a>2、A a&#x3D;b；</h3><p>调用的是拷贝构造函数，而不是拷贝赋值。</p>
<h3 id="3、C-四部分：面向过程，面向对象，模板，STL"><a href="#3、C-四部分：面向过程，面向对象，模板，STL" class="headerlink" title="3、C++四部分：面向过程，面向对象，模板，STL"></a>3、C++四部分：面向过程，面向对象，模板，STL</h3><h3 id="4、尽量以const，enum，inline替换-define"><a href="#4、尽量以const，enum，inline替换-define" class="headerlink" title="4、尽量以const，enum，inline替换 #define"></a>4、尽量以const，enum，inline替换 #define</h3><p>前者是编译器处理，后者是预处理器处理。<br>缺点1：例如 #define A 10， 假如A的运用出现错误，编译时出现的问题显示的是10，不容易被发现。<br>缺点2：#define 的东西不分作用域<br>缺点3：加上括号，写出来很复杂。<br>取enum的地址不合法。</p>
<h3 id="5、-mutable的作用是使变量在const成员函数中也能被修改"><a href="#5、-mutable的作用是使变量在const成员函数中也能被修改" class="headerlink" title="5、 mutable的作用是使变量在const成员函数中也能被修改"></a>5、 mutable的作用是使变量在const成员函数中也能被修改</h3><h3 id="6、const和non-const成员函数中避免重复——在non-const中调用const"><a href="#6、const和non-const成员函数中避免重复——在non-const中调用const" class="headerlink" title="6、const和non-const成员函数中避免重复——在non-const中调用const"></a>6、const和non-const成员函数中避免重复——在non-const中调用const</h3><p>需要做个转型动作。将非const成员先转换成const，然后调用const函数，然后再去除const（只能用const_cast），然后返回。</p>
<h3 id="7、考虑跨编译单元初始化顺序时，最好用local-static对象。"><a href="#7、考虑跨编译单元初始化顺序时，最好用local-static对象。" class="headerlink" title="7、考虑跨编译单元初始化顺序时，最好用local static对象。"></a>7、考虑跨编译单元初始化顺序时，最好用local static对象。</h3><p>local static对象是在函数内的static对象，其他的为non-local static对象。</p>
<p>不同的编译单元内的non-local static对象的初始化相对次序并无确切定义。</p>
<p>单例模式</p>
<hr>
<h2 id="构造-x2F-析构-x2F-赋值运算"><a href="#构造-x2F-析构-x2F-赋值运算" class="headerlink" title="构造&#x2F;析构&#x2F;赋值运算"></a>构造&#x2F;析构&#x2F;赋值运算</h2><h3 id="8、虚析构函数"><a href="#8、虚析构函数" class="headerlink" title="8、虚析构函数"></a>8、虚析构函数</h3><p>用基类指针指向派生类对象时（动态绑定）进行析构，则派生类多余部分没销毁干净。</p>
<p>析构函数改成虚函数后，则析构函数调用的是派生类的。</p>
<p>但是，无端设置，会增加存储体积。往往是至少有一个虚函数的类才声明虚析构函数。</p>
<p><strong>纯虚函数</strong>写虚析构函数时也要加 <strong>&#x3D;0</strong>，且要加一份 <strong>空定义</strong></p>
<h3 id="9、不要在构造中或者析构中调用虚函数"><a href="#9、不要在构造中或者析构中调用虚函数" class="headerlink" title="9、不要在构造中或者析构中调用虚函数"></a>9、不要在构造中或者析构中调用虚函数</h3><p>在base构造期间，虚函数不是虚函数。</p>
<h3 id="10、派生类的拷贝构造（拷贝赋值）函数中，一定要将参数传给父类的拷贝构造（拷贝赋值）函数"><a href="#10、派生类的拷贝构造（拷贝赋值）函数中，一定要将参数传给父类的拷贝构造（拷贝赋值）函数" class="headerlink" title="**10、派生类的拷贝构造（拷贝赋值）函数中，一定要将参数传给父类的拷贝构造（拷贝赋值）函数"></a>**10、派生类的拷贝构造（拷贝赋值）函数中，一定要将参数传给父类的拷贝构造（拷贝赋值）函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a)：<span class="built_in">f</span>(a.f)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        f=a.f;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B&amp; b):<span class="built_in">A</span>(b),<span class="built_in">q</span>(b.q)<span class="comment">//将参数传给父类的拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    B&amp; <span class="keyword">operator</span>=(<span class="type">const</span> B&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        A::<span class="keyword">operator</span>=(b);<span class="comment">//调用父类的拷贝赋值函数</span></span><br><span class="line">        q=b.q;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<hr>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="11、用对象管理资源"><a href="#11、用对象管理资源" class="headerlink" title="11、用对象管理资源"></a>11、用对象管理资源</h3><p>避免过早的return，导致在末尾的delete语句没有执行而发生资源泄漏，利用对象的析构函数可解决这个问题。</p>
<p>两个关键：</p>
<p>1、在获得资源后立即放进管理对象内。2、运用析构函数确保资源被释放。</p>
<h3 id="12、auto-ptr和share-ptr"><a href="#12、auto-ptr和share-ptr" class="headerlink" title="12、auto_ptr和share_ptr"></a>12、auto_ptr和share_ptr</h3><p>auto_ptrs的拷贝构造、拷贝赋值会将本身变回null，而复制所得的指针将会获得资源的唯一拥有权，有点不正常，因此不能用于容器</p>
<p>shared_ptr引入了计数器，不会有以上性质，可用于容器。</p>
<p>并且，auto_ptr和share_ptr不能指向动态分配的数组，因为他们的析构函数是delete，而不是delete [].</p>
<h3 id="13、资源管理类小心copying行为"><a href="#13、资源管理类小心copying行为" class="headerlink" title="13、资源管理类小心copying行为"></a>13、资源管理类小心copying行为</h3><p>通常两种行为：</p>
<p>1、禁止复制，私有继承Uncopyable（它的拷贝操作是私有的）。</p>
<p>2、对底层资源祭出“引用计数法”——shared_ptr，若想在shared_ptr计数为0时不被删除，则需要定义它的删除器。</p>
<p>shared_ptr构造函数接受两个参数，第一个参数类型必须为指针，第二个参数为删除器。</p>
<h3 id="14、资源管理类一般要提供一个方法来访问底层资源"><a href="#14、资源管理类一般要提供一个方法来访问底层资源" class="headerlink" title="14、资源管理类一般要提供一个方法来访问底层资源"></a>14、资源管理类一般要提供一个方法来访问底层资源</h3><p>通常两个手段：</p>
<p>1、显式get函数 （一般比较安全）</p>
<p>2、隐式转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span> <span class="params">()</span> <span class="type">const</span> <span class="comment">//隐式转换函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>：</span><br><span class="line">        FontHandle f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="15、delete数组时应该要加中括号"><a href="#15、delete数组时应该要加中括号" class="headerlink" title="15、delete数组时应该要加中括号"></a>15、delete数组时应该要加中括号</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> A[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span> [] A;</span><br></pre></td></tr></table></figure>



<h3 id="16、以独立语句将newed对象置入智能指针"><a href="#16、以独立语句将newed对象置入智能指针" class="headerlink" title="16、以独立语句将newed对象置入智能指针"></a>16、以独立语句将newed对象置入智能指针</h3><p>避免资源泄漏</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw,<span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>






<hr>
<h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="17、尽量让接口和系统自带的接口行为相似"><a href="#17、尽量让接口和系统自带的接口行为相似" class="headerlink" title="17、尽量让接口和系统自带的接口行为相似"></a>17、尽量让接口和系统自带的接口行为相似</h3><h3 id="18、函数传参尽量传引用"><a href="#18、函数传参尽量传引用" class="headerlink" title="18、函数传参尽量传引用"></a>18、函数传参尽量传引用</h3><p>优点：</p>
<p>1、速度快</p>
<p>2、防止对象切割（子类以by value形式传给父类）</p>
<h3 id="19、避免返回不存在的对象（返回引用）"><a href="#19、避免返回不存在的对象（返回引用）" class="headerlink" title="19、避免返回不存在的对象（返回引用）"></a>19、避免返回不存在的对象（返回引用）</h3><p>这里的引用是函数声明式的返回类型是 <strong>引用</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下列是容易出现的错误代码</span></span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; ls,<span class="type">const</span> Rational&amp; rs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Rational <span class="title">result</span><span class="params">(ls.n * rs.n , ls.d * rs.d)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> result;<span class="comment">//等下返回的对象会被删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="20、成员变量设置为private，提高封装程度"><a href="#20、成员变量设置为private，提高封装程度" class="headerlink" title="20、成员变量设置为private，提高封装程度"></a>20、成员变量设置为private，提高封装程度</h3><p>protected 并不比 public 更具有封装性。</p>
<h3 id="21、外部函数比成员函数更好，可提高封装程度"><a href="#21、外部函数比成员函数更好，可提高封装程度" class="headerlink" title="21、外部函数比成员函数更好，可提高封装程度"></a>21、外部函数比成员函数更好，可提高封装程度</h3><p>增加类的可延伸性；降低编译相依度。</p>
<p>外部函数不能访问私有成员，因此提高了封装程度。</p>
<h3 id="22、若所有参数皆需类型转换，请为此采用non-member函数"><a href="#22、若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="22、若所有参数皆需类型转换，请为此采用non-member函数"></a>22、若所有参数皆需类型转换，请为此采用non-member函数</h3><p>类的加减乘除重载，且该函数不一定需要成为类的友元。</p>
<h3 id="23、写一个好的swap函数的考虑过程"><a href="#23、写一个好的swap函数的考虑过程" class="headerlink" title="23、写一个好的swap函数的考虑过程"></a>23、写一个好的swap函数的考虑过程</h3><p>1、当std::swap效率不高时，提供一个 <strong>swap成员函数</strong></p>
<p>2、提供一个no-member的swap来调用成员版本 <strong>来访问私有成员</strong></p>
<p>3、若想在swap成员函数中使用stl的swap，使用**using std::swap **而不是 <strong>std::swap(a,b)</strong> ，后者是强制调用，前者是使stl中的得以暴露，然后根据命名空间的搜索过程来寻找合适的。</p>
<hr>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="24、尽可能延后变量定义式的出现时间"><a href="#24、尽可能延后变量定义式的出现时间" class="headerlink" title="24、尽可能延后变量定义式的出现时间"></a>24、尽可能延后变量定义式的出现时间</h3><p>如果在程序抛出异常了，太早定义这个变量，它就有可能没被使用，但消耗了成本。</p>
<p>并且最好<strong>延后到能够给它初值为止</strong>，因为这样<strong>可以直接定义</strong>，而不是赋值。（赋值通常比较慢）</p>
<h3 id="25、尽量少转型"><a href="#25、尽量少转型" class="headerlink" title="25、尽量少转型"></a>25、尽量少转型</h3><p>1、要用用新式的。</p>
<p>2、（假如手上只有一个基类指针，但是想要调用派生类函数）</p>
<p>​      避免dynamic_casts的两种方式：</p>
<p>​      a.基类虚函数设置为空，派生类虚函数设置内容。（区分函数职能）</p>
<p>​      b.<strong>将基类指针存储在派生类类型的容器</strong>中，然后用迭代器解引用调用。</p>
<h3 id="26、尽量避免返回handles（指针、引用、迭代器）指向对象内部"><a href="#26、尽量避免返回handles（指针、引用、迭代器）指向对象内部" class="headerlink" title="26、尽量避免返回handles（指针、引用、迭代器）指向对象内部"></a>26、尽量避免返回handles（指针、引用、迭代器）指向对象内部</h3><p>降低了封装性。——可采用增加const</p>
<p>但是增加了const还是不好，有可能出现指针指向虚调号码牌（临时对象，但是在调用后被删除了）。</p>
<h3 id="27、减少抛出异常"><a href="#27、减少抛出异常" class="headerlink" title="27、减少抛出异常"></a>27、减少抛出异常</h3><p>一个一般化的设计策略——<strong>copy and swap</strong>，为你打算修改的对象做一份副本，然后在副本上修改。若有任何修改错误，那么原对象保持不变，只有在所有修改成功后，才做替换。</p>
<p>实际上，一般是将所有数据放置一个对象中，然后原对象通过一个指针指向那个数据对象（副本）（<strong>pimpl idiom</strong>手法）。</p>
<p>同时，一个函数操作得越多，那这个函数越容易抛出异常。</p>
<h3 id="28、-了解inline"><a href="#28、-了解inline" class="headerlink" title="28、 了解inline"></a>28、 了解inline</h3><p>过度会造成程序体积太大（占用内存变大——额外换页，降低缓存效率等）</p>
<ul>
<li><p>函数体在class内的，都是inline。（包括友元函数）</p>
</li>
<li><p>inline函数一般放在头文件中；</p>
</li>
<li><p>virtual函数、通过函数指针调用的函数、构造析构函数拒绝inline</p>
</li>
<li><p>debug版本一般也拒绝inline，在不存在的函数中打断点很困难。</p>
</li>
</ul>
<h3 id="29、实现与接口分离"><a href="#29、实现与接口分离" class="headerlink" title="**29、实现与接口分离"></a>**29、实现与接口分离</h3><p>第一种手法：</p>
<p>A对象中存一个指针pa，pa指针（<strong>接口</strong>）指向具体实现的对象（<strong>实现类</strong>）。（<strong>pimpl idiom</strong>手法）（<strong>代理模式</strong>）</p>
<ul>
<li><p>如果能够，声明式比定义式好。</p>
</li>
<li><p>为声明式和定义式提供不同的头文件。（比如一个文件只需要声明，就只用包含.h文件）</p>
</li>
</ul>
<p><strong>第二种手法</strong>：</p>
<p>把接口定义为纯虚类，但该纯虚类中有一个<strong>create函数（工厂函数）</strong>，create函数返回一个<strong>类型为自身，但指向派生类</strong>的指针（使用接口类的构造函数，构造函数参数为派生类的构造函数的返回值），这样就可以利用多态来进行运用真正的函数（派生类中的）。</p>
<p>实现类继承上述纯虚类，并<strong>覆盖所有的纯虚函数</strong>。</p>
<p>详细见P145</p>
<h3 id="30、public继承-x3D-is-a"><a href="#30、public继承-x3D-is-a" class="headerlink" title="30、public继承&#x3D;is a"></a>30、public继承&#x3D;is a</h3><h3 id="31、避免遮掩而来的名称"><a href="#31、避免遮掩而来的名称" class="headerlink" title="31、避免遮掩而来的名称"></a>31、避免遮掩而来的名称</h3><p>如果派生类与父类的函数<strong>同名但是参数类型不同</strong>，那么父类的函数<strong>不会被继承</strong>，就算调用时采用的是父类的参数格式，也调用不到。</p>
<p>若想解决，可以<strong>使用using声明</strong>，此时两者都可以用。若只想继承一种（父类有同名的两种），可以用<strong>转交函数</strong>，因为using会全部继承下来。</p>
<h3 id="32、区分接口继承和实现继承"><a href="#32、区分接口继承和实现继承" class="headerlink" title="32、区分接口继承和实现继承"></a>32、区分接口继承和实现继承</h3><ul>
<li>纯虚函数的目的是让派生类只继承接口。</li>
</ul>
<p>​       基函数的纯虚函数也可以有定义，但是调用它的方式只有通过指明 类名称。</p>
<ul>
<li>普通虚函数的目的是让派生类继承接口和缺省版本。</li>
<li>非虚函数的目的是让派生类继承接口和一份强制性实现。</li>
</ul>
<p><strong>一个灵活的手法</strong>：父类为纯虚函数，里面有定义（缺省版本），派生类中想用缺省版本的，在虚函数中指定父类名称调用缺省版本，不想要缺省版本的自己定义。（一种比较次的方法是父类定义纯虚函数和一个缺省的非虚函数，派生类想要用缺省版本的，在纯虚函数调用继承下来的非虚函数，不想要的自己定义。有一点不好就是，假如该非虚函数是protected的，不想暴露，但是纯虚函数是公开的，这样就给暴露了，降低了封装性）</p>
<p>注意：纯虚函数不是不可以定义，而是一般没有作用，对于含有纯虚函数的抽象类，不可以实例化对象。</p>
<h3 id="33、虚函数的替代方案"><a href="#33、虚函数的替代方案" class="headerlink" title="**33、虚函数的替代方案"></a>**33、虚函数的替代方案</h3><p>模板模式使用Non-Virtual Interface手法实现——将具有多态性质的函数设置为非虚函数，在该函数中调用真正的虚函数，这样真正的虚函数就可以设置为private。</p>
<p>策略模式使得同一类，可以有不同的健康计算函数。</p>
<p>虚函数的替代方案：</p>
<ul>
<li>NVI手法，模板模式的一种特殊情况，用public非虚函数包含低访问性的虚函数</li>
<li>把虚函数替换为函数指针变量——策略模式的一种特例。</li>
<li>用std:function 替换虚函数</li>
<li>传统策略模式</li>
</ul>
<h3 id="34、绝不重新定义继承而来的非虚函数"><a href="#34、绝不重新定义继承而来的非虚函数" class="headerlink" title="34、绝不重新定义继承而来的非虚函数"></a>34、绝不重新定义继承而来的非虚函数</h3><h3 id="35、绝不重新定义继承而来的缺省参数值"><a href="#35、绝不重新定义继承而来的缺省参数值" class="headerlink" title="35、绝不重新定义继承而来的缺省参数值"></a>35、绝不重新定义继承而来的缺省参数值</h3><p>当继承一个带有缺省参数值的虚函数，虚函数是动态绑定，<strong>缺省参数值却是静态绑定</strong>。</p>
<h3 id="36、慎用Private继承，它意味着——根据某物实现出"><a href="#36、慎用Private继承，它意味着——根据某物实现出" class="headerlink" title="36、慎用Private继承，它意味着——根据某物实现出"></a>36、慎用Private继承，它意味着——根据某物实现出</h3><p>由于private继承将基类的所有public都改为private，因此，可以将private继承视为继承子类的实现而略去子类的接口(因为子类的接口由于private的原因不能再被调用者调用，相当于接口被取消)</p>
<p>用public继承和复合也许更好，虽然会复杂一点。</p>
<h3 id="37、菱形继承得采用——虚继承"><a href="#37、菱形继承得采用——虚继承" class="headerlink" title="37、菱形继承得采用——虚继承"></a>37、菱形继承得采用——虚继承</h3><p><strong>菱形的左右</strong> 虚继承于 <strong>菱形的上顶点</strong></p>
<p>理论上看，public继承应该总是virtual的，但是虚继承有成本。</p>
<hr>
<h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><h3 id="38、typename的另一种用法"><a href="#38、typename的另一种用法" class="headerlink" title="38、typename的另一种用法"></a>38、typename的另一种用法</h3><p>编译器可能不知道下面是个迭代器指针类型，因为可能是C类型中有个成员变量叫做const_iterator，又或者是x是个全局变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf2nd</span><span class="params">(<span class="type">const</span> C&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C::const_iterator x;<span class="comment">//C::const_iterator是个嵌套从属类型，这是个错误代码，正确写法应该在前面加一个typename</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，不得在 <strong>基类列</strong> 和 <strong>成员初值列</strong> 内以它作为基类的修饰符。</p>
<h3 id="39、运用成员函数模板接受所有兼容类型"><a href="#39、运用成员函数模板接受所有兼容类型" class="headerlink" title="39、运用成员函数模板接受所有兼容类型"></a>39、运用成员函数模板接受所有兼容类型</h3><p>以带有Base-Derived关系的B、D两类型分别具现化某个模板，他们产生的<strong>两个具现体并不具有继承关系</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Smartptr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Smartptr</span><span class="params">(<span class="type">const</span> Smartptr&lt;U&gt;&amp; other)</span>:holder(other.get())//叫做泛化构造函数</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T* get &#123;<span class="keyword">return</span> holder;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中使用 U* 指针去初始化 T* 指针，筛选了函数群（如果不这样，那么任何一个类型U都可以初始化T），使得只有使用子类才能初始化（向上兼容）。</p>
<p>当你写了泛化构造函数，还是要去写正常的copy构造函数和拷贝赋值函数。</p>
<p>成员函数模板还有一个功能就是赋值。（比如shared_ptr中可以兼容内置指针，weak_ptr，auto_ptr的赋值）</p>
<h3 id="40、一个模板类的乘法，其他类型想隐式转换为模板类型，需要定义非成员函数"><a href="#40、一个模板类的乘法，其他类型想隐式转换为模板类型，需要定义非成员函数" class="headerlink" title="40、一个模板类的乘法，其他类型想隐式转换为模板类型，需要定义非成员函数"></a>40、一个模板类的乘法，其他类型想隐式转换为模板类型，需要定义非成员函数</h3><p>在模板中写函数，且该函数是friend的，且函数体在模板类中，而不是成员函数。</p>
<p>详细看条款46</p>
<hr>
<h2 id="还不是很明白的"><a href="#还不是很明白的" class="headerlink" title="还不是很明白的"></a>还不是很明白的</h2><p>条款8</p>
<p>条款25</p>
<p>条款46</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2022/08/20/High-Concurrency-Architecture/" rel="next" title="大并发服务器架构和优化手段">
      大并发服务器架构和优化手段 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC"><span class="nav-number">1.</span> <span class="nav-text">让自己习惯C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81-%E5%A4%9A%E7%94%A8explicit"><span class="nav-number">1.1.</span> <span class="nav-text">1、 多用explicit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81A-a-x3D-b%EF%BC%9B"><span class="nav-number">1.2.</span> <span class="nav-text">2、A a&#x3D;b；</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81C-%E5%9B%9B%E9%83%A8%E5%88%86%EF%BC%9A%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%EF%BC%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%A8%A1%E6%9D%BF%EF%BC%8CSTL"><span class="nav-number">1.3.</span> <span class="nav-text">3、C++四部分：面向过程，面向对象，模板，STL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%B0%BD%E9%87%8F%E4%BB%A5const%EF%BC%8Cenum%EF%BC%8Cinline%E6%9B%BF%E6%8D%A2-define"><span class="nav-number">1.4.</span> <span class="nav-text">4、尽量以const，enum，inline替换 #define</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81-mutable%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BD%BF%E5%8F%98%E9%87%8F%E5%9C%A8const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E4%B9%9F%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9"><span class="nav-number">1.5.</span> <span class="nav-text">5、 mutable的作用是使变量在const成员函数中也能被修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81const%E5%92%8Cnon-const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E2%80%94%E2%80%94%E5%9C%A8non-const%E4%B8%AD%E8%B0%83%E7%94%A8const"><span class="nav-number">1.6.</span> <span class="nav-text">6、const和non-const成员函数中避免重复——在non-const中调用const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E8%80%83%E8%99%91%E8%B7%A8%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E6%97%B6%EF%BC%8C%E6%9C%80%E5%A5%BD%E7%94%A8local-static%E5%AF%B9%E8%B1%A1%E3%80%82"><span class="nav-number">1.7.</span> <span class="nav-text">7、考虑跨编译单元初始化顺序时，最好用local static对象。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0-x2F-%E6%9E%90%E6%9E%84-x2F-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="nav-number">2.</span> <span class="nav-text">构造&#x2F;析构&#x2F;赋值运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">8、虚析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%9E%84%E9%80%A0%E4%B8%AD%E6%88%96%E8%80%85%E6%9E%90%E6%9E%84%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">9、不要在构造中或者析构中调用虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%EF%BC%88%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%EF%BC%89%E5%87%BD%E6%95%B0%E4%B8%AD%EF%BC%8C%E4%B8%80%E5%AE%9A%E8%A6%81%E5%B0%86%E5%8F%82%E6%95%B0%E4%BC%A0%E7%BB%99%E7%88%B6%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%EF%BC%88%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%EF%BC%89%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.</span> <span class="nav-text">**10、派生类的拷贝构造（拷贝赋值）函数中，一定要将参数传给父类的拷贝构造（拷贝赋值）函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">资源管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="nav-number">3.1.</span> <span class="nav-text">11、用对象管理资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E3%80%81auto-ptr%E5%92%8Cshare-ptr"><span class="nav-number">3.2.</span> <span class="nav-text">12、auto_ptr和share_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13%E3%80%81%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E5%B0%8F%E5%BF%83copying%E8%A1%8C%E4%B8%BA"><span class="nav-number">3.3.</span> <span class="nav-text">13、资源管理类小心copying行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14%E3%80%81%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%80%E8%88%AC%E8%A6%81%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E6%9D%A5%E8%AE%BF%E9%97%AE%E5%BA%95%E5%B1%82%E8%B5%84%E6%BA%90"><span class="nav-number">3.4.</span> <span class="nav-text">14、资源管理类一般要提供一个方法来访问底层资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15%E3%80%81delete%E6%95%B0%E7%BB%84%E6%97%B6%E5%BA%94%E8%AF%A5%E8%A6%81%E5%8A%A0%E4%B8%AD%E6%8B%AC%E5%8F%B7"><span class="nav-number">3.5.</span> <span class="nav-text">15、delete数组时应该要加中括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16%E3%80%81%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86newed%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">3.6.</span> <span class="nav-text">16、以独立语句将newed对象置入智能指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="nav-number">4.</span> <span class="nav-text">设计与声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#17%E3%80%81%E5%B0%BD%E9%87%8F%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%A1%8C%E4%B8%BA%E7%9B%B8%E4%BC%BC"><span class="nav-number">4.1.</span> <span class="nav-text">17、尽量让接口和系统自带的接口行为相似</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18%E3%80%81%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E5%B0%BD%E9%87%8F%E4%BC%A0%E5%BC%95%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">18、函数传参尽量传引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19%E3%80%81%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%88%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">19、避免返回不存在的对象（返回引用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE%E4%B8%BAprivate%EF%BC%8C%E6%8F%90%E9%AB%98%E5%B0%81%E8%A3%85%E7%A8%8B%E5%BA%A6"><span class="nav-number">4.4.</span> <span class="nav-text">20、成员变量设置为private，提高封装程度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21%E3%80%81%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E6%AF%94%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%9B%B4%E5%A5%BD%EF%BC%8C%E5%8F%AF%E6%8F%90%E9%AB%98%E5%B0%81%E8%A3%85%E7%A8%8B%E5%BA%A6"><span class="nav-number">4.5.</span> <span class="nav-text">21、外部函数比成员函数更好，可提高封装程度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22%E3%80%81%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0"><span class="nav-number">4.6.</span> <span class="nav-text">22、若所有参数皆需类型转换，请为此采用non-member函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23%E3%80%81%E5%86%99%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84swap%E5%87%BD%E6%95%B0%E7%9A%84%E8%80%83%E8%99%91%E8%BF%87%E7%A8%8B"><span class="nav-number">4.7.</span> <span class="nav-text">23、写一个好的swap函数的考虑过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#24%E3%80%81%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4"><span class="nav-number">5.1.</span> <span class="nav-text">24、尽可能延后变量定义式的出现时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25%E3%80%81%E5%B0%BD%E9%87%8F%E5%B0%91%E8%BD%AC%E5%9E%8B"><span class="nav-number">5.2.</span> <span class="nav-text">25、尽量少转型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26%E3%80%81%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%EF%BC%88%E6%8C%87%E9%92%88%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8"><span class="nav-number">5.3.</span> <span class="nav-text">26、尽量避免返回handles（指针、引用、迭代器）指向对象内部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27%E3%80%81%E5%87%8F%E5%B0%91%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-number">5.4.</span> <span class="nav-text">27、减少抛出异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28%E3%80%81-%E4%BA%86%E8%A7%A3inline"><span class="nav-number">5.5.</span> <span class="nav-text">28、 了解inline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29%E3%80%81%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%8E%A5%E5%8F%A3%E5%88%86%E7%A6%BB"><span class="nav-number">5.6.</span> <span class="nav-text">**29、实现与接口分离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30%E3%80%81public%E7%BB%A7%E6%89%BF-x3D-is-a"><span class="nav-number">5.7.</span> <span class="nav-text">30、public继承&#x3D;is a</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31%E3%80%81%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="nav-number">5.8.</span> <span class="nav-text">31、避免遮掩而来的名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32%E3%80%81%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="nav-number">5.9.</span> <span class="nav-text">32、区分接口继承和实现继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="nav-number">5.10.</span> <span class="nav-text">**33、虚函数的替代方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34%E3%80%81%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E9%9D%9E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">5.11.</span> <span class="nav-text">34、绝不重新定义继承而来的非虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35%E3%80%81%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="nav-number">5.12.</span> <span class="nav-text">35、绝不重新定义继承而来的缺省参数值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36%E3%80%81%E6%85%8E%E7%94%A8Private%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%AE%83%E6%84%8F%E5%91%B3%E7%9D%80%E2%80%94%E2%80%94%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA"><span class="nav-number">5.13.</span> <span class="nav-text">36、慎用Private继承，它意味着——根据某物实现出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37%E3%80%81%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%BE%97%E9%87%87%E7%94%A8%E2%80%94%E2%80%94%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">5.14.</span> <span class="nav-text">37、菱形继承得采用——虚继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">模板与泛型编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#38%E3%80%81typename%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%94%A8%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">38、typename的另一种用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39%E3%80%81%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.2.</span> <span class="nav-text">39、运用成员函数模板接受所有兼容类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40%E3%80%81%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E4%B9%98%E6%B3%95%EF%BC%8C%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E6%83%B3%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%9C%80%E8%A6%81%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.</span> <span class="nav-text">40、一个模板类的乘法，其他类型想隐式转换为模板类型，需要定义非成员函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%98%E4%B8%8D%E6%98%AF%E5%BE%88%E6%98%8E%E7%99%BD%E7%9A%84"><span class="nav-number">7.</span> <span class="nav-text">还不是很明白的</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="llf333"
      src="/images/llf.jpg">
  <p class="site-author-name" itemprop="name">llf333</p>
  <div class="site-description" itemprop="description">Every man is the master of his own fortune.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/llf333" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;llf333" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa-light fa-watermelon-slice"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">llf333</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
